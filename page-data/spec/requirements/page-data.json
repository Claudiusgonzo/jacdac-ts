{"componentChunkName":"component---src-components-spec-tsx","path":"/spec/requirements/","result":{"data":{"mdx":{"id":"cde7aa50-3389-546c-8e5f-90c1d4dc7143","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Requirements\"), mdx(\"p\", null, \"MCUs implementing JACDAC typically need the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a UART module\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"DMA for said UART (if device does nothing but JACDAC, it may be fine to skip this)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"some source of randomness; can be ADC of a floating input or internal temperature sensor\")), mdx(\"p\", null, \"It is possible not to use DMA, if the MCU isn't doing anything else (eg., our bootloader\\nimplementations doesn't use DMA nor interrupts).\"), mdx(\"p\", null, \"It's important that devices don't come up with the same \\\"random\\\" numbers every time\\nthey power on, and critical that two instances of the same device don't that.\\nTypically, you can take temperature readings a couple thousand times (they will fluctuate slightly),\\nhash the results and use that as a random seed.\\nOther option is a floating ADC.\\nYet another is timing pin capacitance.\\nInitial contents of RAM does not appear to be random, despite the fact that it may look like it is.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":""}}},"pageContext":{"id":"cde7aa50-3389-546c-8e5f-90c1d4dc7143"}}}